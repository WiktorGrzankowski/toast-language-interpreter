-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Toast.SkelToast where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Toast.AbsToast

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transIdent :: Toast.AbsToast.Ident -> Result
transIdent x = case x of
  Toast.AbsToast.Ident string -> failure x

transProgram :: Toast.AbsToast.Program -> Result
transProgram x = case x of
  Toast.AbsToast.Prg stmts -> failure x

transArg :: Toast.AbsToast.Arg -> Result
transArg x = case x of
  Toast.AbsToast.Ar type_ ident -> failure x
  Toast.AbsToast.ArgRef type_ ident -> failure x

transBlock :: Toast.AbsToast.Block -> Result
transBlock x = case x of
  Toast.AbsToast.Blk stmts -> failure x

transStmt :: Toast.AbsToast.Stmt -> Result
transStmt x = case x of
  Toast.AbsToast.Empty -> failure x
  Toast.AbsToast.BStmt block -> failure x
  Toast.AbsToast.Decl type_ items -> failure x
  Toast.AbsToast.Ass ident expr -> failure x
  Toast.AbsToast.Incr ident -> failure x
  Toast.AbsToast.Decr ident -> failure x
  Toast.AbsToast.Ret expr -> failure x
  Toast.AbsToast.VRet -> failure x
  Toast.AbsToast.Cond expr block -> failure x
  Toast.AbsToast.CondElse expr block1 block2 -> failure x
  Toast.AbsToast.While expr block -> failure x
  Toast.AbsToast.Break -> failure x
  Toast.AbsToast.Continue -> failure x
  Toast.AbsToast.SPrint expr -> failure x
  Toast.AbsToast.FnDef type_ ident args block -> failure x

transItem :: Toast.AbsToast.Item -> Result
transItem x = case x of
  Toast.AbsToast.NoInit ident -> failure x
  Toast.AbsToast.Init ident expr -> failure x

transType :: Toast.AbsToast.Type -> Result
transType x = case x of
  Toast.AbsToast.TInt -> failure x
  Toast.AbsToast.TStr -> failure x
  Toast.AbsToast.TBool -> failure x

transExprArg :: Toast.AbsToast.ExprArg -> Result
transExprArg x = case x of
  Toast.AbsToast.EArg expr -> failure x
  Toast.AbsToast.EArgRef ident -> failure x

transExpr :: Toast.AbsToast.Expr -> Result
transExpr x = case x of
  Toast.AbsToast.EVar ident -> failure x
  Toast.AbsToast.ELitInt integer -> failure x
  Toast.AbsToast.ELitTrue -> failure x
  Toast.AbsToast.ELitFalse -> failure x
  Toast.AbsToast.EApp ident args -> failure x
  Toast.AbsToast.EString string -> failure x
  Toast.AbsToast.Neg expr -> failure x
  Toast.AbsToast.Not expr -> failure x
  Toast.AbsToast.EMul expr1 mulop expr2 -> failure x
  Toast.AbsToast.EAdd expr1 addop expr2 -> failure x
  Toast.AbsToast.ERel expr1 relop expr2 -> failure x
  Toast.AbsToast.EAnd expr1 expr2 -> failure x
  Toast.AbsToast.EOr expr1 expr2 -> failure x

transAddOp :: Toast.AbsToast.AddOp -> Result
transAddOp x = case x of
  Toast.AbsToast.Plus -> failure x
  Toast.AbsToast.Minus -> failure x

transMulOp :: Toast.AbsToast.MulOp -> Result
transMulOp x = case x of
  Toast.AbsToast.Times -> failure x
  Toast.AbsToast.Div -> failure x
  Toast.AbsToast.Mod -> failure x

transRelOp :: Toast.AbsToast.RelOp -> Result
transRelOp x = case x of
  Toast.AbsToast.LTH -> failure x
  Toast.AbsToast.LE -> failure x
  Toast.AbsToast.GTH -> failure x
  Toast.AbsToast.GE -> failure x
  Toast.AbsToast.EQU -> failure x
  Toast.AbsToast.NE -> failure x
